#!/usr/bin/env bash
# hm-list: list packages managed by Home Manager.
# - Default: shows declared packages with installation status and versions
# - --installed: shows all installed packages (including implicit deps)
# - --declared: shows only declared package names (no status)

set -euo pipefail

HM_DIR="${HM_DIR:-$HOME/.config/home-manager}"
HOME_NIX="$HM_DIR/home.nix"

print_help() {
  cat <<'EOF'
Usage:
  hm-list                 List declared packages with install status & versions
  hm-list --installed     List all installed packages (includes dependencies)
  hm-list --declared      List only declared package names (plain list)
  hm-list --search <term> Filter packages by pattern
  hm-list --help | -h     Show this help

Options:
  --installed, -i   Show all installed packages from home-manager
  --declared, -d    Show only declared package names (no status check)
  --search, -s      Filter output by pattern
  --count, -c       Show count only
EOF
}

# Extract packages from home.packages block in home.nix
list_declared() {
  if [[ ! -f "$HOME_NIX" ]]; then
    echo "Error: $HOME_NIX not found" >&2
    exit 1
  fi

  awk '
    /home\.packages[[:space:]]*=/ { inblock=1; next }
    inblock && /\];/ { exit }
    inblock {
      if ($0 ~ /^[[:space:]]*#/ || $0 ~ /^[[:space:]]*$/) next
      if ($0 ~ /\(/) next
      gsub(/^[[:space:]]+/, "")
      gsub(/[[:space:]]+$/, "")
      gsub(/pkgs\./, "")
      if ($0 ~ /^[\[\]]/ || $0 ~ /=/) next
      if (length($0) > 0) print
    }
  ' "$HOME_NIX" | sort
}

list_installed() {
  home-manager packages 2>/dev/null | sort
}

# Show declared packages with installation status
list_with_status() {
  local declared installed pkg match version

  declared=$(list_declared)
  installed=$(list_installed)

  # Find max package name length for alignment
  local max_len=0
  while IFS= read -r pkg; do
    (( ${#pkg} > max_len )) && max_len=${#pkg}
  done <<< "$declared"

  while IFS= read -r pkg; do
    [[ -z "$pkg" ]] && continue
    # Search for this package in installed list
    # Try exact match first (pkg-version), then prefix match (pkg-something-version)
    match=$(echo "$installed" | grep -E "^${pkg}-[0-9]" | head -1 || true)
    if [[ -z "$match" ]]; then
      # Try prefix match for wrapped packages (e.g., mpv -> mpv-with-scripts-0.41.0)
      match=$(echo "$installed" | grep -E "^${pkg}-[a-z].*-[0-9]" | head -1 || true)
    fi
    if [[ -n "$match" ]]; then
      # Extract version: last hyphen-separated segment starting with digit
      version=$(echo "$match" | grep -oE '[0-9][0-9.a-z]*$' || echo "$match")
      printf "%-${max_len}s  %s %s\n" "$pkg" "installed" "$version"
    else
      printf "%-${max_len}s  %s\n" "$pkg" "not found"
    fi
  done <<< "$declared"
}

# Parse arguments
MODE="status"  # default: show status
SEARCH=""
COUNT_ONLY=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --help|-h)
      print_help
      exit 0
      ;;
    --installed|-i)
      MODE="installed"
      shift
      ;;
    --declared|-d)
      MODE="declared"
      shift
      ;;
    --search|-s)
      SEARCH="${2:-}"
      [[ -z "$SEARCH" ]] && { echo "Error: --search requires a pattern" >&2; exit 1; }
      shift 2
      ;;
    --count|-c)
      COUNT_ONLY=1
      shift
      ;;
    *)
      echo "Unknown option: $1" >&2
      print_help
      exit 1
      ;;
  esac
done

# Execute based on mode
case "$MODE" in
  status)
    OUTPUT=$(list_with_status)
    ;;
  declared)
    OUTPUT=$(list_declared)
    ;;
  installed)
    OUTPUT=$(list_installed)
    ;;
esac

# Apply search filter
if [[ -n "$SEARCH" ]]; then
  OUTPUT=$(echo "$OUTPUT" | grep -i "$SEARCH" || true)
fi

# Output
if [[ $COUNT_ONLY -eq 1 ]]; then
  echo "$OUTPUT" | grep -c . || echo 0
else
  if [[ -z "$OUTPUT" ]]; then
    echo "No packages found."
  else
    echo "$OUTPUT"
  fi
fi
